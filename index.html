<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="theme-color" content="#0a0b0d">
<link rel="manifest" href="manifest.json">
<title>Tetris ‚Äì Full (Hold + Pause + Sound)</title>
<style>
  :root { --bg:#ffffff; --panel:#15161a; --ink:#0b0b0f; --muted:#586174; --board:#0a0b0d; }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%; background:var(--bg)}
  body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--ink)}
  .wrap{min-height:100svh; display:grid; place-items:center; padding:12px}
  .shell{display:grid; gap:12px; grid-template-columns:minmax(260px,1fr) 220px; align-items:start; width:min(1000px,96vw)}
  .panel{background:var(--panel); border:1px solid #24262b; border-radius:16px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.25); color:#e8ecf1}
  .headline{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
  h1{font-size:18px; margin:0}
  .muted{color:#9aa4b2; font-size:12px}
  .grid{display:grid; gap:10px}
  .stats{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
  .stat{background:#0f1115; border:1px solid #1f2227; border-radius:12px; padding:10px; text-align:center}
  .stat .k{font-size:12px; color:#9aa4b2}
  .stat .v{font-size:22px; font-weight:800}
  canvas{display:block; width:100%; height:auto; image-rendering:pixelated; background:var(--board); border-radius:12px; border:1px solid #202329}
  .side .panel{padding:14px}
  .controls{display:flex; flex-wrap:wrap; gap:8px}
  .btn{background:#0f1115; border:1px solid #23262d; border-radius:999px; padding:8px 12px; font-size:12px; color:#e8ecf1; font-weight:700; cursor:pointer}
  .btn.big{padding:14px 18px; font-size:16px; border-radius:16px}
  .btn:active{transform:translateY(1px)}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace; background:#0f1115; border:1px solid #23262d; border-radius:6px; padding:2px 6px; font-size:11px}
  .overlay{position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.55); border-radius:16px}
  .overlay .card{background:#111318; border:1px solid #252a31; padding:18px 20px; border-radius:14px; text-align:center}
  .note{font-size:11px; color:#9aa4b2}
  /* Mobile pad */
  .mobile-pad{position:fixed; left:0; right:0; bottom:env(safe-area-inset-bottom); padding:10px 12px calc(10px + env(safe-area-inset-bottom)); backdrop-filter:saturate(140%) blur(8px); background:rgba(10,12,16,.8); border-top:1px solid #21252b; display:none; z-index:50}
  .pad-grid{display:grid; grid-template-columns:1.3fr 1fr 1.3fr; gap:10px; align-items:stretch}
  .pad-left,.pad-mid,.pad-right{display:grid; gap:10px}
  .pad-left{grid-template-columns:repeat(3,1fr)}
  .pad-mid{grid-template-columns:repeat(2,1fr)}
  .pad-right{grid-template-columns:repeat(4,1fr)}
  .pad-btn{background:#12151b; border:1px solid #272c34; border-radius:14px; padding:14px 10px; font-size:18px; text-align:center; user-select:none; color:#f6fbff; font-weight:800; text-shadow:0 1px 0 rgba(0,0,0,.6)}
  .pad-btn:active{transform:scale(.98)}
  @media (max-width: 900px){
    .shell{grid-template-columns:1fr; padding-bottom:110px}
    .controls{display:none}
    .mobile-pad{display:block}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="shell">
      <!-- MAIN -->
      <div class="panel" style="position:relative">
        <div class="headline">
          <h1>Tetris</h1>
          <div class="muted">‚Üê ‚Üí move ¬∑ ‚Üì soft drop ¬∑ <span class="kbd">Z</span>/<span class="kbd">X</span> rotate ¬∑ Space drop ¬∑ <span class="kbd">C</span> hold ¬∑ <span class="kbd">P</span> pause</div>
          <div class="controls">
            <button class="btn" id="btn-left">‚üµ</button>
            <button class="btn" id="btn-right">‚ü∂</button>
            <button class="btn" id="btn-down">‚ü±</button>
            <button class="btn" id="btn-rot-l">‚ü≤</button>
            <button class="btn" id="btn-rot-r">‚ü≥</button>
            <button class="btn" id="btn-hold">HOLD</button>
            <button class="btn" id="btn-drop">DROP</button>
            <button class="btn" id="btn-pause">PAUSE</button>
            <button class="btn" id="btn-restart">RESTART</button>
            <button class="btn" id="btn-mute">üîä</button>
          </div>
        </div>
        <div class="grid">
          <canvas id="board" aria-label="Tetris board"></canvas>
          <div class="stats">
            <div class="stat"><div class="k">Score</div><div id="score" class="v">0</div></div>
            <div class="stat"><div class="k">Level</div><div id="level" class="v">0</div></div>
            <div class="stat"><div class="k">Lines</div><div id="lines" class="v">0</div></div>
          </div>
          <div class="note">Tip: Hard drop gives a small bonus per row. Level rises every 10 lines.</div>
        </div>
        <div id="overlay" class="overlay" style="display:none">
          <div class="card">
            <div id="overlay-title" style="font-weight:800; font-size:22px; margin-bottom:6px">Paused</div>
            <div id="overlay-sub" style="opacity:.8; margin-bottom:12px">Tap resume</div>
            <button class="btn big" id="overlay-btn">Resume</button>
          </div>
        </div>
      </div>
      <!-- SIDE -->
      <div class="side">
        <div class="panel">
          <div class="k">Next</div>
          <canvas id="next" width="160" height="300" style="width:100%; height:auto"></canvas>
        </div>
        <div class="panel" style="margin-top:12px">
          <div class="k">Hold</div>
          <canvas id="hold" width="160" height="120" style="width:100%; height:auto"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- MOBILE PAD -->
  <div class="mobile-pad" id="mobile-pad" role="group" aria-label="Mobile controls">
    <div class="pad-grid">
      <div class="pad-left">
        <button class="pad-btn" id="mp-left">‚üµ</button>
        <button class="pad-btn" id="mp-down">‚ü±</button>
        <button class="pad-btn" id="mp-right">‚ü∂</button>
      </div>
      <div class="pad-mid">
        <button class="pad-btn" id="mp-rot-l">‚ü≤</button>
        <button class="pad-btn" id="mp-rot-r">‚ü≥</button>
      </div>
      <div class="pad-right">
        <button class="pad-btn" id="mp-hold">HOLD</button>
        <button class="pad-btn" id="mp-drop">DROP</button>
        <button class="pad-btn" id="mp-pause">‚è∏</button>
        <button class="pad-btn" id="mp-mute">üîä</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ====== CONFIG ======
  const COLS=10, ROWS=20, VISIBLE_ROWS=20;
  const COLORS={I:"#00bcd4",O:"#ffc107",T:"#9c27b0",S:"#4caf50",Z:"#f44336",J:"#3f51b5",L:"#ff9800",GHOST:"rgba(255,255,255,.12)"};
  const LINE_SCORES=[0,100,300,500,800];
  const MIN_INTERVAL=90, SOFT_DROP_SPEEDUP=0.25;

  const SHAPES={
    I:[[[0,1],[1,1],[2,1],[3,1]],[[2,0],[2,1],[2,2],[2,3]],[[0,2],[1,2],[2,2],[3,2]],[[1,0],[1,1],[1,2],[1,3]]],
    O:[[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]],[[1,0],[2,0],[1,1],[2,1]]],
    T:[[[1,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[2,1],[1,2]],[[1,0],[0,1],[1,1],[1,2]]],
    S:[[[1,0],[2,0],[0,1],[1,1]],[[1,0],[1,1],[2,1],[2,2]],[[1,1],[2,1],[0,2],[1,2]],[[0,0],[0,1],[1,1],[1,2]]],
    Z:[[[0,0],[1,0],[1,1],[2,1]],[[2,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[1,2],[2,2]],[[1,0],[0,1],[1,1],[0,2]]],
    J:[[[0,0],[0,1],[1,1],[2,1]],[[1,0],[2,0],[1,1],[1,2]],[[0,1],[1,1],[2,1],[2,2]],[[1,0],[1,1],[0,2],[1,2]]],
    L:[[[2,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[1,2],[2,2]],[[0,1],[1,1],[2,1],[0,2]],[[0,0],[1,0],[1,1],[1,2]]],
  };
  const PIECES=Object.keys(SHAPES);

  // ====== STATE ======
  let board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  let queue=[], hold=null, canHold=true;
  let cur=null;
  let score=0, lines=0, level=0;
  let running=true, gameOver=false;
  let lastTime=0, acc=0, dropInterval=800, softDropping=false;

  // ====== AUDIO ======
  const AudioFX={ctx:null,gain:null,muted:false,ready:false,
    ensure(){ if(this.ready) return; try{ const C=window.AudioContext||window.webkitAudioContext; this.ctx=new C(); this.gain=this.ctx.createGain(); this.gain.gain.value=0.12; this.gain.connect(this.ctx.destination); this.ready=true; }catch(e){}},
    resume(){ this.ctx && this.ctx.state==='suspended' && this.ctx.resume(); },
    setMuted(m){ this.muted=m; updateMuteUI(); },
    beep(f=440,d=0.06,type='sine',v=1){ if(this.muted||!this.ready)return; const o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.type=type; o.frequency.value=f; o.connect(g); g.connect(this.gain); const t=this.ctx.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.9*v,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+d); o.start(t); o.stop(t+d+0.05); },
    chord(fs=[440,660],d=0.1,type='sine'){ fs.forEach((f,i)=>this.beep(f,d*(1+0.05*i),type,0.85)); },
    sweep(f0=300,f1=900,d=0.25,type='sine'){ if(this.muted||!this.ready)return; const o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.type=type; o.frequency.setValueAtTime(f0,this.ctx.currentTime); o.frequency.linearRampToValueAtTime(f1,this.ctx.currentTime+d); o.connect(g); g.connect(this.gain); const t=this.ctx.currentTime; g.gain.setValueAtTime(0.8,t); g.gain.exponentialRampToValueAtTime(0.0001,t+d); o.start(t); o.stop(t+d+0.02); }
  };
  function hookAudioOnce(){ const h=()=>{ AudioFX.ensure(); AudioFX.resume(); window.removeEventListener('touchstart',h,true); window.removeEventListener('mousedown',h,true); window.removeEventListener('keydown',h,true); }; window.addEventListener('touchstart',h,true); window.addEventListener('mousedown',h,true); window.addEventListener('keydown',h,true); }
  function updateMuteUI(){ const d=document.getElementById('btn-mute'); const m=document.getElementById('mp-mute'); const icon=AudioFX.muted?'üîá':'üîä'; if(d)d.textContent=icon; if(m)m.textContent=icon; }

  // ====== DOM ======
  const boardCanvas=document.getElementById('board');
  const nextCanvas=document.getElementById('next');
  const holdCanvas=document.getElementById('hold');
  const scoreEl=document.getElementById('score');
  const levelEl=document.getElementById('level');
  const linesEl=document.getElementById('lines');
  const overlay=document.getElementById('overlay');
  const overlayTitle=document.getElementById('overlay-title');
  const overlaySub=document.getElementById('overlay-sub');
  const overlayBtn=document.getElementById('overlay-btn');

  // ====== CANVAS SCAFFOLD ======
  function setupCanvas(canvas,wBlocks,hBlocks,size){
    const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
    canvas.width=wBlocks*size*dpr; canvas.height=hBlocks*size*dpr;
    canvas.style.width=(wBlocks*size)+'px'; canvas.style.height=(hBlocks*size)+'px';
    const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); return ctx;
  }
  let SIZE_REF={value:28};
  let ctx=setupCanvas(boardCanvas,COLS,VISIBLE_ROWS,SIZE_REF.value);
  let nctx=setupCanvas(nextCanvas,6,15,16);
  let hctx=setupCanvas(holdCanvas,6,5,16);

  function fitBoard(){
    const panel=document.querySelector('.panel');
    const pad=document.getElementById('mobile-pad');
    const headerH=84; const padH=pad?.offsetHeight||0;
    const usableW=Math.min(panel.clientWidth, window.innerWidth*0.98);
    const usableH=(window.innerHeight||document.documentElement.clientHeight) - headerH - padH - 24;
    const byW=Math.floor(usableW/(COLS+2)); const byH=Math.floor(usableH/(VISIBLE_ROWS+2));
    const block=Math.max(18, Math.min(42, Math.min(byW,byH)));
    SIZE_REF.value=block; ctx=setupCanvas(boardCanvas,COLS,VISIBLE_ROWS,block); drawAll();
  }

  // ====== LOGIC ======
  const inBounds=(x,y)=>x>=0&&x<COLS&&y>=0&&y<ROWS;
  function canPlace(t,x,y,r){
    for(const [dx,dy] of SHAPES[t][r]){ const px=x+dx, py=y+dy;
      if(!inBounds(px,py) || board[py][px]!=null) return false;
    } return true;
  }
  function merge(t,x,y,r){ for(const [dx,dy] of SHAPES[t][r]){ const px=x+dx, py=y+dy; if(inBounds(px,py)) board[py][px]=COLORS[t]; } }
  function isRowFull(row){ for(let x=0;x<COLS;x++){ if(row[x]==null) return false; } return true; }
  function clearLines(){
    let cleared=0; for(let y=ROWS-1;y>=0;y--){ if(isRowFull(board[y])){ board.splice(y,1); board.unshift(Array(COLS).fill(null)); cleared++; y++; } }
    return cleared;
  }
  const levelFromLines=t=>Math.floor(t/10);
  const intervalFromLevel=l=>Math.max(MIN_INTERVAL, 800 - l*70);
  function getDropY(t,x,y,r){ while(canPlace(t,x,y+1,r)) y++; return y; }

  function* bagGen(){ let bag=[]; while(true){ if(bag.length===0) bag=[...PIECES].sort(()=>Math.random()-0.5); yield bag.pop(); } }
  const bagIter=bagGen();
  function fillQueue(){ while(queue.length<5) queue.push(bagIter.next().value); }
  function spawn(type=null){
    fillQueue(); const t=type||queue.shift(); cur={type:t,x:3,y:0,r:0}; canHold=true;
    if(!canPlace(cur.type,cur.x,cur.y,cur.r)){ running=false; gameOver=true; showOverlay('Game Over',`Score: ${score}`,'Restart'); AudioFX.chord([160,120],0.25,'sawtooth'); drawAll(); }
  }
  function holdPiece(){
    if(!canHold||!cur) return; canHold=false;
    if(hold){ const tmp=hold; hold=cur.type; cur={type:tmp,x:3,y:0,r:0};
      if(!canPlace(cur.type,cur.x,cur.y,cur.r)){ running=false; gameOver=true; showOverlay('Game Over',`Score: ${score}`,'Restart'); AudioFX.chord([160,120],0.25,'sawtooth'); }
    } else { hold=cur.type; spawn(); }
    drawSide(); AudioFX.chord([300,240],0.07,'triangle');
  }

  function updateStats(){ scoreEl.textContent=Math.floor(score); levelEl.textContent=level; linesEl.textContent=lines; }

  function reset(){
    board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    queue=[]; hold=null; canHold=true; score=0; lines=0; level=0;
    running=true; gameOver=false; acc=0; lastTime=0;
    dropInterval=intervalFromLevel(level);
    spawn(); hideOverlay(); updateStats(); drawAll();
  }

  // ====== RENDER ======
  function drawCell(ctx,x,y,color,size){
    const pad=1; ctx.fillStyle=color; ctx.fillRect(x*size+pad,y*size+pad,size-pad*2,size-pad*2);
    ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(x*size+pad,y*size+pad,size-pad*2,3);
    ctx.fillStyle='rgba(0,0,0,.2)'; ctx.fillRect(x*size+pad,y*size+size-3-pad,size-pad*2,3);
  }
  function drawBoard(){
    const SIZE=SIZE_REF.value; ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
    for(let y=ROWS-VISIBLE_ROWS, vy=0; y<ROWS; y++,vy++){
      for(let x=0;x<COLS;x++){ const c=board[y][x];
        if(c) drawCell(ctx,x,vy,c,SIZE);
        else { ctx.fillStyle='#0f1115'; ctx.fillRect(x*SIZE+1, vy*SIZE+1, SIZE-2, SIZE-2); }
      }
    }
    if(cur && running && !gameOver){
      const gy=getDropY(cur.type,cur.x,cur.y,cur.r);
      for(const [dx,dy] of SHAPES[cur.type][cur.r]){ const x=cur.x+dx, y=cur.y+dy+(gy-cur.y); if(y>=ROWS-VISIBLE_ROWS) drawCell(ctx,x,y-(ROWS-VISIBLE_ROWS),COLORS.GHOST,SIZE); }
      for(const [dx,dy] of SHAPES[cur.type][cur.r]){ const x=cur.x+dx, y=cur.y+dy; if(y>=ROWS-VISIBLE_ROWS) drawCell(ctx,x,y-(ROWS-VISIBLE_ROWS),COLORS[cur.type],SIZE); }
    }
  }
  function drawSide(){
    const cellSize=16; nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height); let yOff=0; fillQueue();
    for(let i=0;i<Math.min(5,queue.length);i++){ const k=queue[i], shape=SHAPES[k][0];
      let minX=99,minY=99,maxX=-99,maxY=-99;
      for(const [x,y] of shape){ minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
      const w=maxX-minX+1, h=maxY-minY+1; const ox=Math.floor((6-w)/2)-minX, oy=Math.floor((3-h)/2)-minY;
      nctx.fillStyle='#0f1115'; nctx.fillRect(0,yOff*cellSize,6*cellSize,3*cellSize);
      for(const [x,y] of shape){ const pad=1, rx=(x+ox)*cellSize+pad, ry=(y+oy+yOff*1)*cellSize+pad;
        nctx.fillStyle=COLORS[k]; nctx.fillRect(rx,ry,cellSize-pad*2,cellSize-pad*2);
        nctx.fillStyle='rgba(255,255,255,.12)'; nctx.fillRect(rx,ry,cellSize-pad*2,3);
        nctx.fillStyle='rgba(0,0,0,.2)'; nctx.fillRect(rx,ry+cellSize-3,cellSize-pad*2,3);
      } yOff+=3.2;
    }
    hctx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
    if(hold){ const shape=SHAPES[hold][0]; let minX=99,minY=99,maxX=-99,maxY=-99;
      for(const [x,y] of shape){ minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
      const w=maxX-minX+1,h=maxY-minY+1, ox=Math.floor((6-w)/2)-minX, oy=Math.floor((5-h)/2)-minY;
      for(const [x,y] of shape){ drawCell(hctx,x+ox,y+oy,COLORS[hold],16); }
    }
  }
  function drawAll(){ drawBoard(); drawSide(); }

  // ====== OVERLAY/PAUSE ======
  function showOverlay(t,s,b){ overlayTitle.textContent=t; overlaySub.textContent=s||''; overlayBtn.textContent=b||'OK'; overlay.style.display='grid'; }
  function hideOverlay(){ overlay.style.display='none'; }
  function pauseToggle(){ if(gameOver) return; running=!running; if(!running){ showOverlay('Paused','Tap resume','Resume'); AudioFX.beep(280,0.08,'sine'); } else { hideOverlay(); AudioFX.beep(560,0.08,'sine'); } }
  overlayBtn.addEventListener('click',()=>{ if(gameOver) reset(); else pauseToggle(); });

  // ====== CONTROLS ======
  function rotate(dir){
    const nr=(cur.r+(dir===1?1:3))%4;
    const kicks=[[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1],[1,-1],[-1,-1]];
    for(const [kx,ky] of kicks){
      const nx=cur.x+kx, ny=cur.y+ky;
      if(canPlace(cur.type,nx,ny,nr)){ cur.x=nx; cur.y=ny; cur.r=nr; AudioFX.beep(520,0.05,'triangle'); return; }
    }
  }
  function hardDrop(){ const dropY=getDropY(cur.type,cur.x,cur.y,cur.r); const dist=dropY-cur.y; if(dist>0){ score+=dist; updateStats(); } cur.y=dropY; AudioFX.sweep(220,160,0.07,'square'); lock(); }
  function softDrop(){ if(canPlace(cur.type,cur.x,cur.y+1,cur.r)){ cur.y++; AudioFX.beep(220,0.03,'sine'); } else lock(); }
  function move(dx){ if(canPlace(cur.type,cur.x+dx,cur.y,cur.r)){ cur.x+=dx; AudioFX.beep(360,0.03,'sine'); } }

  function lock(){
    merge(cur.type,cur.x,cur.y,cur.r);
    const beforeLevel=level;
    const cleared=clearLines();
    if(cleared>0){
      score += LINE_SCORES[cleared]*(1+level*0.1);
      lines += cleared; level = levelFromLines(lines); dropInterval=intervalFromLevel(level);
      updateStats();
      const chords={1:[523],2:[523,659],3:[659,784],4:[523,659,784]}; AudioFX.chord(chords[cleared]||[523],0.09,'sine');
      if(level>beforeLevel) AudioFX.sweep(440,880,0.18,'triangle');
      tryVibrate(20);
    }
    spawn(); drawSide(); drawBoard();
  }

  document.addEventListener('keydown',e=>{
    if(e.repeat) return;
    if(e.key==='p'||e.key==='P'){ pauseToggle(); return; }
    if(e.key==='r'||e.key==='R'){ reset(); return; }
    if(!running||gameOver) return;
    if(e.key==='ArrowLeft') move(-1);
    else if(e.key==='ArrowRight') move(1);
    else if(e.key==='ArrowDown'){ softDropping=true; softDrop(); }
    else if(e.key===' '){ e.preventDefault(); hardDrop(); }
    else if(e.key==='z'||e.key==='Z') rotate(-1);
    else if(e.key==='x'||e.key==='X'||e.key==='ArrowUp') rotate(1);
    else if(e.key==='c'||e.key==='C') holdPiece();
    drawBoard();
  },{passive:false});
  document.addEventListener('keyup',e=>{ if(e.key==='ArrowDown') softDropping=false; },{passive:true});

  // Buttons
  const $=id=>document.getElementById(id);
  function addHoldRepeat(el, onStep, interval=85, firstDelay=220){
    let t1,t2; const start=(e)=>{ e.preventDefault?.(); onStep(); drawBoard();
      t1=setTimeout(()=>{ t2=setInterval(()=>{ onStep(); drawBoard(); }, interval); }, firstDelay); };
    const end=()=>{ clearTimeout(t1); clearInterval(t2); };
    el.addEventListener('touchstart',start,{passive:false}); el.addEventListener('touchend',end);
    el.addEventListener('mousedown',start); el.addEventListener('mouseup',end); el.addEventListener('mouseleave',end);
  }
  addHoldRepeat($('mp-left'), ()=>{ if(running) move(-1); });
  addHoldRepeat($('mp-right'),()=>{ if(running) move(1);  });
  addHoldRepeat($('mp-down'), ()=>{ if(running) softDrop(); });
  $('mp-rot-l').onclick = ()=>{ if(running){ rotate(-1); drawBoard(); } };
  $('mp-rot-r').onclick = ()=>{ if(running){ rotate(1);  drawBoard(); } };
  $('mp-hold').onclick   = ()=>{ if(running){ holdPiece(); drawBoard(); } };
  $('mp-drop').onclick   = ()=>{ if(running){ hardDrop(); } };
  $('mp-pause').onclick  = ()=>{ pauseToggle(); };
  $('mp-mute').onclick   = ()=>{ AudioFX.ensure(); AudioFX.setMuted(!AudioFX.muted); };
  $('btn-left')?.addEventListener('click', ()=>{ if(running){ move(-1); drawBoard(); }});
  $('btn-right')?.addEventListener('click',()=>{ if(running){ move(1);  drawBoard(); }});
  $('btn-down')?.addEventListener('click', ()=>{ if(running){ softDrop(); drawBoard(); }});
  $('btn-rot-l')?.addEventListener('click',()=>{ if(running){ rotate(-1); drawBoard(); }});
  $('btn-rot-r')?.addEventListener('click',()=>{ if(running){ rotate(1);  drawBoard(); }});
  $('btn-hold')?.addEventListener('click',()=>{ if(running){ holdPiece(); drawBoard(); }});
  $('btn-drop')?.addEventListener('click', ()=>{ if(running){ hardDrop(); }});
  $('btn-pause')?.addEventListener('click',()=>{ pauseToggle(); });
  $('btn-restart')?.addEventListener('click',()=>{ reset(); });
  $('btn-mute')?.addEventListener('click',()=>{ AudioFX.ensure(); AudioFX.setMuted(!AudioFX.muted); });

  function tryVibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  // Gestures
  let tSX=0,tSY=0,tST=0,moved=false;
  boardCanvas.addEventListener('touchstart',e=>{
    if(!running||gameOver) return;
    const t=e.changedTouches[0]; tSX=t.clientX; tSY=t.clientY; tST=Date.now(); moved=false;
  },{passive:true});
  boardCanvas.addEventListener('touchmove',e=>{
    if(!running||gameOver) return;
    const t=e.changedTouches[0]; const dx=t.clientX-tSX, dy=t.clientY-tSY; const th=22;
    if(Math.abs(dx)>Math.abs(dy)){
      if(dx>th){ move(1);  tSX=t.clientX; moved=true; }
      else if(dx<-th){ move(-1); tSX=t.clientX; moved=true; }
    } else if(dy>th){ softDrop(); tSY=t.clientY; moved=true; }
    drawBoard();
  },{passive:true});
  boardCanvas.addEventListener('touchend',e=>{
    if(!running||gameOver) return;
    const dt=Date.now()-tST; const dy=e.changedTouches[0].clientY - tSY;
    if(!moved && dy<-60){ hardDrop(); }
    else if(!moved && dt<200){ rotate(1); drawBoard(); }
    else if(!moved && dt>=200 && dt<500){ rotate(-1); drawBoard(); }
  },{passive:true});

  // Loop
  function loop(ts){
    if(!lastTime) lastTime=ts;
    const dt=ts-lastTime; lastTime=ts;
    if(running && !gameOver){
      acc += dt;
      const interval=softDropping?Math.max(MIN_INTERVAL,dropInterval*SOFT_DROP_SPEEDUP):dropInterval;
      if(acc>=interval){ if(canPlace(cur.type,cur.x,cur.y+1,cur.r)) cur.y++; else lock(); acc=0; }
      drawBoard();
    } else {
      drawBoard();
    }
    requestAnimationFrame(loop);
  }

  // Start
  reset(); requestAnimationFrame(loop);
  window.addEventListener('resize',fitBoard,{passive:true}); fitBoard();
  hookAudioOnce(); updateMuteUI();

  // SW register (subpath-safe)
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js'));
  }
})();
</script>
</body>
</html>
